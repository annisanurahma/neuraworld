#!/usr/bin/env node
import { readFileSync } from "node:fs";
import { Command } from "commander";
import { input } from "@inquirer/prompts";
import { skillsCommand } from "./commands/capabilities.js";
import { cancelCommand } from "./commands/cancel.js";
import { configGetCommand, configSetCommand } from "./commands/config.js";
import { setConfigPath } from "./lib/config.js";
import { claudeCommand, creditsCommand, modelsCommand, opencodeCommand, setupClaudeCodeCommand, setupCursorCommand, setupOpenclawCommand, setupOpenCodeCommand, } from "./commands/llm.js";
import { loginCommand } from "./commands/login.js";
import { logoutCommand } from "./commands/logout.js";
import { promptCommand } from "./commands/prompt.js";
import { signCommand } from "./commands/sign.js";
import { statusCommand } from "./commands/status.js";
import { submitCommand, submitJsonCommand } from "./commands/submit.js";
import { whoamiCommand } from "./commands/whoami.js";
import * as output from "./lib/output.js";
const pkg = JSON.parse(readFileSync(new URL("../package.json", import.meta.url), "utf-8"));
/**
 * Read prompt text from stdin (piped) or interactively.
 * Bypasses shell expansion so dollar signs and special characters are preserved.
 */
async function readPromptInput() {
    // Piped stdin (e.g. echo 'buy $50 of ETH' | bankr prompt)
    if (!process.stdin.isTTY) {
        const chunks = [];
        for await (const chunk of process.stdin) {
            chunks.push(chunk);
        }
        const text = Buffer.concat(chunks).toString().trim();
        if (!text) {
            output.error("No input received from stdin");
            process.exit(1);
        }
        return text;
    }
    // Interactive input â€” shell expansion does not apply here
    const text = await input({
        message: "Enter your prompt:",
        theme: output.bankrTheme,
        required: true,
    });
    return text.trim();
}
const program = new Command();
function colorizeHelp(text) {
    return text
        .split("\n")
        .map((line) => {
        // "Usage: ..." line
        if (line.startsWith("Usage:"))
            return output.fmt.brandBold(line);
        // Section headers: "Options:" and "Commands:"
        if (/^(Options|Commands):/.test(line))
            return output.fmt.brandBold(line);
        // Description line (standalone, no leading whitespace, no colon)
        if (line === "Bankr AI agent CLI")
            return output.fmt.brandBold(line);
        // Command/option rows: leading whitespace then content
        if (/^\s{2,}\S/.test(line)) {
            const match = line.match(/^(\s+)([\w<>[\].\-,/ ]+?)(\s{2,}.+)$/);
            if (match) {
                return (match[1] + output.fmt.brand(match[2]) + output.fmt.dim(match[3]));
            }
        }
        return line;
    })
        .join("\n");
}
program
    .name("bankr")
    .description("Bankr AI agent CLI")
    .version(pkg.version, "-v, --version", "Show CLI version")
    .helpOption("-h, --help", "Display help")
    .addHelpCommand("help [command]", "Display help for command")
    .option("--config <path>", "Path to config file (default: ~/.bankr/config.json)")
    .configureOutput({
    writeOut: (str) => process.stdout.write(colorizeHelp(str)),
    writeErr: (str) => process.stderr.write(colorizeHelp(str)),
})
    .hook("preAction", (thisCommand) => {
    const configPath = thisCommand.opts().config;
    if (configPath) {
        setConfigPath(configPath);
    }
});
const loginCmd = program
    .command("login")
    .description("Authenticate with the Bankr API")
    .option("--api-url <url>", "Custom Bankr API URL (default: https://api.bankr.bot)")
    .option("--api-key <key>", "Bankr API key (skip interactive prompts)")
    .option("--llm-key <key>", "Separate LLM gateway key (optional, defaults to API key)")
    .option("--url", "Print the dashboard URL and exit")
    .action(async (opts) => {
    await loginCommand({
        apiUrl: opts.apiUrl,
        apiKey: opts.apiKey,
        llmKey: opts.llmKey,
        url: opts.url,
    });
});
loginCmd
    .command("email [address]")
    .description("Sign in with email (sends verification code)")
    .option("--code <otp>", "OTP code (step 2 of headless login)")
    .option("--accept-terms", "Accept Terms of Service (skips prompt)")
    .option("--key-name <name>", "API key name (default: CLI)")
    .option("--read-write", "Enable write operations on the API key")
    .option("--llm", "Enable LLM gateway on the API key")
    .action(async (address, opts, cmd) => {
    const parentOpts = cmd.parent.opts();
    await loginCommand({
        apiUrl: parentOpts.apiUrl,
        llmKey: parentOpts.llmKey,
        email: address ?? "",
        code: opts.code,
        acceptTerms: opts.acceptTerms,
        keyName: opts.keyName,
        readWrite: opts.readWrite,
        llm: opts.llm,
    });
});
program
    .command("logout")
    .description("Clear stored credentials")
    .action(logoutCommand);
program
    .command("whoami")
    .description("Show current authentication info")
    .action(whoamiCommand);
program
    .command("prompt [text...]")
    .description("Send a prompt to the Bankr AI agent")
    .option("--thread <id>", "Continue a specific conversation thread")
    .option("-c, --continue", "Continue the most recent thread")
    .action(async (text, opts) => {
    const joined = text.join(" ").trim();
    await promptCommand(joined || (await readPromptInput()), opts);
});
program
    .command("status <jobId>")
    .description("Check the status of a job")
    .action(statusCommand);
program
    .command("cancel <jobId>")
    .description("Cancel a running job")
    .action(cancelCommand);
const configCmd = program
    .command("config")
    .description("Manage CLI configuration");
configCmd
    .command("get [key]")
    .description("Get config value(s). Keys: apiKey, apiUrl, llmKey, llmUrl")
    .action(configGetCommand);
configCmd
    .command("set <key> <value>")
    .description("Set a config value. Keys: apiKey, apiUrl, llmKey, llmUrl")
    .action(configSetCommand);
program
    .command("skills")
    .description("Show all Bankr AI agent skills with examples")
    .action(skillsCommand);
program
    .command("sign")
    .description("Sign messages, typed data, or transactions")
    .requiredOption("-t, --type <type>", "Signature type: personal_sign, eth_signTypedData_v4, eth_signTransaction")
    .option("-m, --message <message>", "Message to sign (for personal_sign)")
    .option("--typed-data <json>", "EIP-712 typed data as JSON (for eth_signTypedData_v4)")
    .option("--transaction <json>", "Transaction as JSON (for eth_signTransaction)")
    .action(async (opts) => {
    await signCommand({
        type: opts.type,
        message: opts.message,
        typedData: opts.typedData,
        transaction: opts.transaction,
    });
});
const submitCmd = program
    .command("submit")
    .description("Submit a transaction to the blockchain");
submitCmd
    .command("tx")
    .description("Submit transaction with explicit parameters")
    .requiredOption("--to <address>", "Destination address")
    .requiredOption("--chain-id <id>", "Chain ID (8453=Base, 1=Ethereum, 137=Polygon)")
    .option("--value <wei>", "Value in wei")
    .option("--data <hex>", "Calldata (hex string)")
    .option("--gas <limit>", "Gas limit")
    .option("--gas-price <wei>", "Gas price (legacy)")
    .option("--max-fee-per-gas <wei>", "Max fee per gas (EIP-1559)")
    .option("--max-priority-fee-per-gas <wei>", "Max priority fee (EIP-1559)")
    .option("--nonce <n>", "Transaction nonce")
    .option("-d, --description <text>", "Description for logging")
    .option("--no-wait", "Don't wait for confirmation")
    .action(async (opts) => {
    await submitCommand({
        to: opts.to,
        chainId: opts.chainId,
        value: opts.value,
        data: opts.data,
        gas: opts.gas,
        gasPrice: opts.gasPrice,
        maxFeePerGas: opts.maxFeePerGas,
        maxPriorityFeePerGas: opts.maxPriorityFeePerGas,
        nonce: opts.nonce,
        description: opts.description,
        noWait: !opts.wait,
    });
});
submitCmd
    .command("json <transaction>")
    .description("Submit transaction from JSON: {to, chainId, value?, data?}")
    .option("-d, --description <text>", "Description for logging")
    .option("--no-wait", "Don't wait for confirmation")
    .action(async (transaction, opts) => {
    await submitJsonCommand(transaction, {
        noWait: !opts.wait,
        description: opts.description,
    });
});
const llmCmd = program
    .command("llm")
    .description("LLM Gateway tools")
    .action(() => {
    llmCmd.help();
});
llmCmd
    .command("models")
    .description("List available models")
    .action(modelsCommand);
llmCmd
    .command("credits")
    .description("Show LLM gateway credit balance")
    .action(creditsCommand);
const llmSetupCmd = llmCmd
    .command("setup")
    .description("Generate agent config (openclaw, claude, opencode, cursor)");
llmSetupCmd
    .command("openclaw")
    .description("OpenClaw config")
    .option("--install", "Write config to ~/.openclaw/openclaw.json")
    .action(setupOpenclawCommand);
llmSetupCmd
    .command("opencode")
    .description("OpenCode config")
    .option("--install", "Write config to ~/.config/opencode/opencode.json")
    .action(setupOpenCodeCommand);
llmSetupCmd
    .command("cursor")
    .description("Cursor setup")
    .action(setupCursorCommand);
llmSetupCmd
    .command("claude")
    .description("Claude Code config")
    .action(setupClaudeCodeCommand);
llmCmd
    .command("claude")
    .description("Run Claude Code via gateway")
    .allowUnknownOption()
    .allowExcessArguments()
    .action(async () => {
    const idx = process.argv.indexOf("claude");
    const args = idx >= 0 ? process.argv.slice(idx + 1) : [];
    await claudeCommand(args);
});
llmCmd
    .command("opencode")
    .description("Run OpenCode via gateway")
    .allowUnknownOption()
    .allowExcessArguments()
    .action(async () => {
    const idx = process.argv.indexOf("opencode");
    const args = idx >= 0 ? process.argv.slice(idx + 1) : [];
    await opencodeCommand(args);
});
// Default: treat unrecognized arguments as a prompt
program.arguments("[text...]").action(async (text) => {
    if (text.length === 0) {
        program.help();
        return;
    }
    await promptCommand(text.join(" "));
});
async function main() {
    try {
        await program.parseAsync(process.argv);
    }
    catch (err) {
        // User cancelled an interactive prompt (Ctrl+C / Escape)
        if (err.name === "ExitPromptError") {
            console.log();
            process.exit(0);
        }
        output.error(err.message);
        process.exit(1);
    }
}
main();
//# sourceMappingURL=cli.js.map