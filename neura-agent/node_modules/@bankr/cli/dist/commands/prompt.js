import { pollJob, submitPrompt } from "../lib/api.js";
import { getLastThreadId, requireApiKey, setLastThreadId, } from "../lib/config.js";
import * as output from "../lib/output.js";
export async function promptCommand(text, options = {}) {
    requireApiKey();
    // Resolve thread ID from flags
    let threadId;
    if (options.continue) {
        threadId = getLastThreadId();
        if (!threadId) {
            output.error("No previous thread found. Run a prompt first.");
            process.exit(1);
        }
    }
    else if (options.thread) {
        threadId = options.thread;
    }
    let spin = output.spinner("Submitting prompt...");
    let jobId;
    let resolvedThreadId;
    try {
        const res = await submitPrompt(text, threadId);
        jobId = res.jobId;
        resolvedThreadId = res.threadId;
        spin.succeed("Prompt submitted");
        output.label("Job ID", jobId);
        if (resolvedThreadId) {
            output.label("Thread ID", resolvedThreadId);
        }
        console.log();
        spin = output.spinner("Processing...");
    }
    catch (err) {
        spin.fail("Failed to submit prompt");
        output.error(err.message);
        process.exit(1);
    }
    try {
        const startTime = Date.now();
        const result = await pollJob(jobId, {
            interval: 2000,
            onStatus: () => {
                const elapsed = output.formatDuration(Date.now() - startTime);
                spin.text = `Processing... (${elapsed})`;
            },
        });
        // Save thread ID from the final result (or from initial response)
        const finalThreadId = result.threadId ?? resolvedThreadId;
        if (finalThreadId) {
            setLastThreadId(finalThreadId);
        }
        if (result.status === "completed") {
            const elapsed = output.formatDuration(result.processingTime ?? Date.now() - startTime);
            spin.succeed(`Completed in ${elapsed} (${jobId})`);
            console.log();
            if (result.response) {
                console.log(result.response);
            }
            if (result.transactions && result.transactions.length > 0) {
                console.log();
                output.dim(`${result.transactions.length} transaction(s) returned. Use the web app to review and execute.`);
            }
        }
        else if (result.status === "failed") {
            spin.fail(`Job failed (${jobId})`);
            if (result.error) {
                output.error(result.error);
            }
            process.exit(1);
        }
        else if (result.status === "cancelled") {
            spin.warn(`Job was cancelled (${jobId})`);
        }
    }
    catch (err) {
        spin.fail("Error while polling");
        output.error(err.message);
        process.exit(1);
    }
}
//# sourceMappingURL=prompt.js.map